# Day 20: Print Pascal's Triangle

## Problem Description üìù

Write a program to generate the first `n` rows of **Pascal's Triangle**.

### Pascal's Triangle
Pascal's Triangle is a triangular array of binomial coefficients. The first and last element of each row is always `1`, and each other element is the sum of the two numbers directly above it in the previous row.

---

### Example:

#### **Example 1**:

- **Input**:  
  `n = 5`

- **Output**:  
  ```
  [
      [1],
      [1, 1],
      [1, 2, 1],
      [1, 3, 3, 1],
      [1, 4, 6, 4, 1]
  ]
  ```

  **Explanation**:  
  - The first row contains a single `1`.
  - The second row contains two `1`s.
  - The third row is generated by summing the elements from the previous row: `1+1=2`.
  - Similarly, subsequent rows are generated using the sum of two adjacent elements from the previous row.

---

## Function Definition üì¶

### **Function**:  
```java
public static ArrayList<ArrayList<Long>> printPascal(int n)
```

- **Parameters**:
  - `n`: The number of rows of Pascal‚Äôs Triangle to generate.

- **Return Value**:
  - Returns a 2D list (`ArrayList<ArrayList<Long>>`) representing the first `n` rows of Pascal's Triangle.

---

## Algorithm Explanation üöÄ

1. **Iterate through Rows**:
   - We generate each row one by one, starting from row 0 (top of the triangle).
   - The number of elements in each row corresponds to its index + 1.

2. **Construct Each Row**:
   - **First and Last Element**: The first and last elements of each row are always `1`.
   - **Other Elements**: The other elements are computed as the sum of the two elements directly above them from the previous row.
   - We use the formula:  
     `row[j] = result.get(i - 1).get(j - 1) + result.get(i - 1).get(j)`

3. **Store the Row**:  
   - After constructing each row, we add it to the final result list.

4. **Return the Result**:  
   - After all rows have been generated, return the list of rows.

---

## Time Complexity ‚è±Ô∏è

- **Time Complexity**:  
  - **O(n^2)**, because for each row, we generate `i` elements where `i` is the row number, and summing up these elements takes `O(i)` time.

- **Space Complexity**:  
  - **O(n^2)**, as we are storing `n` rows and each row `i` has `i+1` elements.

---

## Sample Input and Output üìä

### **Input 1**:  
```  
n = 5
```

### **Output 1**:  
```  
[
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1]
]
```

---

### **Input 2**:  
```  
n = 3
```

### **Output 2**:  
```  
[
    [1],
    [1, 1],
    [1, 2, 1]
]
```

---

## Key Learnings ‚ú®

1. **Understanding Pascal's Triangle**:
   - The elements in each row of Pascal‚Äôs Triangle are binomial coefficients. The value at position `(i, j)` in the triangle corresponds to the binomial coefficient `C(i, j)`.

2. **Efficient Row Construction**:
   - By leveraging the previous row to generate the current row, we can build the entire triangle iteratively without needing to compute the binomial coefficients from scratch.

3. **Space and Time Complexity**:
   - The time complexity is quadratic due to the nested iteration over rows and elements, but this is optimal for generating Pascal's Triangle.

---
